#+TITLE: Emacs Configuration
#+AUTHOR: Nelson Loyola

This configuration uses the [[https://github.com/jwiegley/use-package][use-package]] package from John Wiegley,
which is a fantastic way to manage package configurations.

I've gotten ideas for this document from the following:

- [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's site]]
- [[https://github.com/wasamasa/dotemacs/blob/master/init.org][Wasamasa]]
- [[https://github.com/danielmai/.emacs.d][Daniel Mai]]'s configuration.

This file is used to generate ~config.el~ using ~org-babel~ in
~init.el~.

* Installing Emacs
** Ubuntu

I've installed Emacs from source
(=git://git.savannah.gnu.org/emacs.git=) and used the =emacs-24.5=
tag. I used the instructions provided by Xah Lee given [[http://ergoemacs.org/emacs/building_emacs_on_linux.html][here]], but first
the following command has to be run.

#+BEGIN_SRC sh
./autogen.sh
#+END_SRC

Then to compile and install, do the following.

#+BEGIN_SRC sh
./configure
make bootstrap
make
sudo make install
#+END_SRC

* Personal Information

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Nelson Loyola"
      user-mail-address "nloyola@gmail.com")
#+END_SRC

* Customize settings

Set up the customize file to its own separate file, instead of saving
customize settings in [[file:init.el][init.el]].

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file)
#+END_SRC

* Font

** Installation

[[http://input.fontbureau.com/download/][Input Font]]: Install it on Ubuntu as follows:

#+BEGIN_SRC sh :tangle no
mv Input-Font.zip ~/.fonts
cd ~/.fonts
unzip Input-Font.zip
#+END_SRC

** Emacs config

And here's how to tell Emacs to use this font. Copy the following line to your
=~/.Xresources= file.

#+BEGIN_SRC sh :tangle no
Emacs.font: Input Mono Condensed-9
#+END_SRC

And then merge the setting to your X server resource database.

#+BEGIN_SRC sh :tangle no
xrdb -merge ~/.Xresources
#+END_SRC

* Sane defaults

** General

Some commands are disabled by default. They are enabled in our config
using the following:

#+BEGIN_SRC emacs-lisp
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'dired-find-alternate-file 'disabled nil)
(put 'erase-buffer 'disabled nil)
#+END_SRC

Sentences end with a single space.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

Set the default major mode to =text-mode=. By default it's =fundamental= mode which is
not what we want. Also, use =text-mode= for the scratch buffer.

#+BEGIN_SRC emacs-lisp
(setq default-major-mode 'text-mode
      initial-major-mode 'text-mode)
#+END_SRC

Don't scroll to middle of the page. Also, scroll line by line, without
scrolloff and try to keep point at the same visual place when
scrolling by page.

#+BEGIN_SRC emacs-lisp
(setq-default scroll-up-aggressively 0.01 scroll-down-aggressively 0.01)
(setq redisplay-dont-pause t
      scroll-step 1
      scroll-margin 3
      scroll-conservatively 10
      scroll-preserve-screen-position t)
#+END_SRC

Level of decoration {1 - 3}, t = max.

#+BEGIN_SRC emacs-lisp
(setq font-lock-maximum-decoration t)
#+END_SRC

For symlinks, automatically follow the link and visit the real file instead.

#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks nil)
#+END_SRC

Make searches case insensitive.

#+BEGIN_SRC emacs-lisp
(setq-default case-fold-search t)
#+END_SRC

Autosave files are created between saves after a sufficient timeout in
the current directory for crash detection, they begin and end with
=#=.  Change this location to the emacs directory.

#+BEGIN_SRC emacs-lisp
(setq auto-save-list-file-prefix "~/.emacs.d/autosave/")
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/autosave/" t)))
#+END_SRC

Set line wrap at column 100.

#+BEGIN_SRC emacs-lisp
(setq fill-column 100)
#+END_SRC

Replace =yes or no= prompt with =y or n= prompt.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Use UTF-8 everywhere.

#+BEGIN_SRC emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+END_SRC

Use spaces instead of tabs.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

Delete the region when typing, just like as we expect nowadays.

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

Highlight matching delimiters.

#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
#+END_SRC

Highlight matches in query-replace mode.

#+BEGIN_SRC emacs-lisp
(setq query-replace-highlight t)
#+END_SRC

Use visual line mode to display long lines.

#+BEGIN_SRC emacs-lisp
(global-visual-line-mode -1)
#+END_SRC

Replace the standard text representation of various identifiers/symbols
with a (arguably) more aesthetically pleasing representation.

#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode +1)
#+END_SRC

Make completion buffers disappear after 10 seconds.

#+BEGIN_SRC emacs-lisp
(add-hook 'completion-setup-hook
          (lambda () (run-at-time 10 nil
                                  (lambda () (delete-windows-on "*Completions*")))))
#+END_SRC

Revert these files without asking.

#+BEGIN_SRC emacs-lisp
(setq revert-without-query '(".*"))
#+END_SRC

Default command when using ~grep~.

#+BEGIN_SRC emacs-lisp
(setq grep-command "grep -nH -r --include=\\* -e  .")
#+END_SRC

Middle-clicking is nice to paste, however it should not adjust point
and paste at the then adjusted point.

#+BEGIN_SRC emacs-lisp
(setq mouse-yank-at-point t)
#+END_SRC

Save clipboard data of other programs in the kill ring when possible.

#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC

Revert file buffers updated outside of emacs, unless I've made changes to
the buffer which I haven't saved.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
#+END_SRC

Set environment variable for shells.

#+BEGIN_SRC emacs-lisp
(setenv "PAGER" "cat")
#+END_SRC

Do not ask me to save files before compiling. Also scroll to the end
of the compilation buffer when it is opened.

#+BEGIN_SRC emacs-lisp
(setq compilation-ask-about-save nil
      compilation-scroll-output t)
#+END_SRC

Enable ANSI colors for compilation buffers.

#+BEGIN_SRC emacs-lisp
;;(require 'ansi-color)
(defun colorize-compilation-buffer ()
  (let ((inhibit-read-only t))
    (ansi-color-apply-on-region (point-min) (point-max))))
(add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+END_SRC

Configure =next-buffer= and =previous-buffer= to only visit file
buffers (has to be called for each frame):

#+BEGIN_SRC emacs-lisp
(set-frame-parameter (selected-frame) 'buffer-predicate #'buffer-file-name)
#+END_SRC

** Disabled features

Turn off auto-save.

#+BEGIN_SRC emacs-lisp
(setq auto-save-default nil)
#+END_SRC

Don't make any backup files.

#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
#+END_SRC

Get rid of the menu bar. Tool bar and scroll bars are disabled in
~init.el~..

#+BEGIN_SRC emacs-lisp
(when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+END_SRC

Turn off the blinking cursor.

#+BEGIN_SRC emacs-lisp
(blink-cursor-mode -1)
#+END_SRC

Don't use dialog boxes

#+BEGIN_SRC emacs-lisp
(setq use-dialog-box nil)
#+END_SRC

Don't want an audible bell.

#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC

** Frame Title

Display the running program and the selected buffer in the frame title.

#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      '("" invocation-name ": " (:eval (replace-regexp-in-string
                                        "^ +" "" (buffer-name)))))
#+END_SRC

** End of file

Don't add new lines past end of file, and indicate unused lines at the
end of the window with a small image in the left fringe.

#+BEGIN_SRC emacs-lisp
(setq next-line-add-newlines nil)
(setq-default indicate-empty-lines t)
#+END_SRC

Add =\n= to end of file if required.

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

** Hi Lock

Automatically cycle through the highlighting faces listed in
~hi-lock-face-defaults~ instead of bothering the user to pick a face
each time.

#+BEGIN_SRC emacs-lisp
(setq hi-lock-auto-select-face t)
#+END_SRC

** Key bindings

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-g M-g")       'goto-line)
(global-set-key (kbd "M-%")           'query-replace-regexp)
;;(global-set-key "\C-x\C-e"          'compile)
(global-set-key (kbd "C-x C-n")       'next-error)
(global-set-key (kbd "C-x C-i")       'c-indent-exp)
(global-set-key (kbd "C-x k")         'kill-this-buffer)

(global-set-key (kbd "<f1>")          'indent-for-tab-command)
(global-set-key [(shift f1)]          'indent-region)
(global-set-key (kbd "<f2>")          '(lambda () (interactive) (save-some-buffers t)))
(global-set-key [(shift f2)]          '(lambda () (interactive) (revert-buffer t t)))
(global-set-key [(shift f3)]          'helm-recentf)
(global-set-key [(meta shift f3)]     'sbt-grep)
(global-set-key [f5]                  'compile)
(global-set-key [(shift f5)]          'toggle-truncate-lines)
(global-set-key [(shift f11)]         'eval-region)
(global-set-key [(control shift f11)] 'align-regexp)
#+END_SRC

** Line numbers.

#+BEGIN_SRC emacs-lisp :tangle no
(dolist (mode-hook '(text-mode-hook prog-mode-hook))
  (add-hook mode-hook
            (lambda ()
              (linum-mode t))))
#+END_SRC

** Mode line

Display the column number in the mode line.

#+BEGIN_SRC emacs-lisp
(column-number-mode t)
#+END_SRC

Use the directory name to make buffer names unique.

#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward)
#+END_SRC

Do not show thees modes in the mode line.

#+BEGIN_SRC emacs-lisp
(diminish 'visual-line-mode)
(diminish 'abbrev-mode)
#+END_SRC
** Remove trailing whitespace

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Shell

#+BEGIN_SRC emacs-lisp
(defvar my-term-shell "/bin/zsh")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)

(defun my-term-use-utf8 ()
  (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
(add-hook 'term-exec-hook 'my-term-use-utf8)

(defun my-term-paste (&optional string)
  (interactive)
  (process-send-string
   (get-buffer-process (current-buffer))
   (if string string (current-kill 0))))

(defun my-term-hook ()
  (goto-address-mode)
  (define-key term-raw-map "\C-y" 'my-term-paste)
  (let ((base03  "#002b36")
        (base02  "#073642")
        (base01  "#586e75")
        (base00  "#657b83")
        (base0   "#839496")
        (base1   "#93a1a1")
        (base2   "#eee8d5")
        (base3   "#fdf6e3")
        (yellow  "#b58900")
        (orange  "#cb4b16")
        (red     "#dc322f")
        (magenta "#d33682")
        (violet  "#6c71c4")
        (blue    "#268bd2")
        (cyan    "#2aa198")
        (green   "#859900"))
    (setq ansi-term-color-vector
          (vconcat `(unspecified ,base02 ,red ,green ,yellow ,blue
                                 ,magenta ,cyan ,base2)))
    (my-term-use-utf8)
    ))

(add-hook 'term-exec-hook 'my-term-hook)
#+END_SRC

Use the whole window when opening up a shell (default behaviour is to
split the window).

#+BEGIN_SRC emacs-lisp
(add-to-list 'display-buffer-alist '("*shell*" display-buffer-same-window))
#+END_SRC

** Text mode

#+BEGIN_SRC emacs-lisp
(setq text-mode-hook
      '(lambda ()
         (turn-on-auto-fill)            ; Enable automatic line wrapping.
         (setq-default indent-tabs-mode nil)))    ; Use real tabs.
#+END_SRC

** Prefer Newer Versions

To reduce the risk of loading outdated byte code files, we set
load-prefer-newer and enable auto-compile-on-load-mode as early as
possible.

#+BEGIN_SRC emacs-lisp
(setq load-prefer-newer t)
#+END_SRC

** Set default browser

#+BEGIN_SRC emacs-lisp
(when (equal system-type 'gnu/linux)
    (setq browse-url-browser-function 'browse-url-generic
          browse-url-generic-program "google-chrome-stable"))
(setenv "BROWSER" "google-chrome-stable")
#+END_SRC

* Packages bundled with Emacs

** =bookmark=

Prefer saving this file somewhere other than the default.

#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file "~/.emacs.d/etc/bookmarks")
#+END_SRC

** =dired=

Make dired show directories first. Dired buffers should auto revert
and not give any use feedback (source: [[http://whattheemacsd.com/sane-defaults.el-01.html][Magnars Sveen]]).

#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-aBhl  --group-directories-first"
      global-auto-revert-non-file-buffers t
      auto-revert-verbose nil
      dired-dwim-target t)
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC

** =ediff=
#+BEGIN_SRC emacs-lisp
(setq ediff-split-window-function 'split-window-horizontally
      ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-diff-options "-bw")
#+END_SRC
** =emacsclient=

#+BEGIN_SRC emacs-lisp
(use-package edit-server
  :ensure t
  :if window-system
  :init
  (add-hook 'after-init-hook 'server-start t)
  (add-hook 'after-init-hook 'edit-server-start t))
#+END_SRC

** =ispell=

Find aspell and hunspell automatically.

Taken from here: http://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs.html

#+BEGIN_SRC emacs-lisp
;; if (aspell installed) { use aspell}
;; else if (hunspell installed) { use hunspell }
;; whatever spell checker I use, I always use English dictionary
;; I prefer use aspell because:
;; 1. aspell is older
;; 2. looks Kevin Atkinson still get some road map for aspell:
;; @see http://lists.gnu.org/archive/html/aspell-announce/2011-09/msg00000.html
(defun flyspell-detect-ispell-args (&optional run-together)
  "if RUN-TOGETHER is true, spell check the CamelCase words."
  (let (args)
    (cond
     ((string-match  "aspell$" ispell-program-name)
      ;; Force the English dictionary for aspell
      ;; Support Camel Case spelling check (tested with aspell 0.6)
      (setq args (list "--sug-mode=ultra" "--lang=en_CA"))
      (if run-together
          (setq args (append args '("--run-together" "--run-together-limit=5" "--run-together-min=2")))))
     ((string-match "hunspell$" ispell-program-name)
      ;; Force the English dictionary for hunspell
      (setq args "-d en_CA")))
    args))

(cond
 ((executable-find "aspell")
  ;; you may also need `ispell-extra-args'
  (setq ispell-program-name "aspell"))
 ((executable-find "hunspell")
  (setq ispell-program-name "hunspell")

  ;; Please note that `ispell-local-dictionary` itself will be passed to hunspell cli with "-d"
  ;; it's also used as the key to lookup ispell-local-dictionary-alist
  ;; if we use different dictionary
  (setq ispell-local-dictionary "en_CA")
  (setq ispell-local-dictionary-alist
        '(("en_CA" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_CA") nil utf-8))))
 (t (setq ispell-program-name nil)))

;; ispell-cmd-args is useless, it's the list of *extra* arguments we will append to the ispell process when "ispell-word" is called.
;; ispell-extra-args is the command arguments which will *always* be used when start ispell process
;; Please note when you use hunspell, ispell-extra-args will NOT be used.
;; Hack ispell-local-dictionary-alist instead.
(setq-default ispell-extra-args (flyspell-detect-ispell-args t))
;; (setq ispell-cmd-args (flyspell-detect-ispell-args))
(defadvice ispell-word (around my-ispell-word activate)
  (let ((old-ispell-extra-args ispell-extra-args))
    (ispell-kill-ispell t)
    (setq ispell-extra-args (flyspell-detect-ispell-args))
    ad-do-it
    (setq ispell-extra-args old-ispell-extra-args)
    (ispell-kill-ispell t)
    ))

(defadvice flyspell-auto-correct-word (around my-flyspell-auto-correct-word activate)
  (let ((old-ispell-extra-args ispell-extra-args))
    (ispell-kill-ispell t)
    ;; use emacs original arguments
    (setq ispell-extra-args (flyspell-detect-ispell-args))
    ad-do-it
    ;; restore our own ispell arguments
    (setq ispell-extra-args old-ispell-extra-args)
    (ispell-kill-ispell t)
    ))

(defun text-mode-hook-setup ()
  ;; Turn off RUN-TOGETHER option when spell check text-mode
  (setq-local ispell-extra-args (flyspell-detect-ispell-args)))
(add-hook 'text-mode-hook 'text-mode-hook-setup)
#+END_SRC

** =ibuffer=

ibuffer is the improved version of list-buffers.

#+BEGIN_SRC emacs-lisp
(defalias 'list-buffers 'ibuffer)
#+END_SRC

** =org-mode=

First some UI and editing tweaks.

Changing the ellipsis idea comes from [[http://endlessparentheses.com/changing-the-org-mode-ellipsis.html][Artur Malabarba]].

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " ⤵"
      org-catch-invisible-edits 'error
      org-startup-indented t
      org-cycle-include-plain-lists 'integrate
      org-return-follows-link t
      org-M-RET-may-split-line nil
      org-src-fontify-natively t
      org-src-preserve-indentation t
      org-enforce-todo-dependencies t
      org-enforce-todo-checkbox-dependencies t
      org-link-frame-setup '((file . find-file))
      org-export-backends '(ascii html icalendar latex md)
      org-log-into-drawer t)

(setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/Dropbox/todo.org" "Tasks")
             "* TODO %?\n  %i\n  %a")
        ("l" "Link" entry (file+headline "~/Dropbox/orgfiles/links.org" "Links")
             "* %? %^L %^g \n%T" :prepend t)
        ("j" "Journal" entry (file+datetree "~/Dropbox/orgfiles/journal.org")
             "* %?\nEntered on %U\n  %i\n  %a")))
#+END_SRC

*** Org activation bindings

Set up some global key bindings that integrate with Org Mode features.

#+BEGIN_SRC emacs-lisp
(bind-key "C-c l" 'org-store-link)
(bind-key "C-c a" 'org-agenda)
#+END_SRC

*** Org agenda

Learned about [[https://github.com/sachac/.emacs.d/blob/83d21e473368adb1f63e582a6595450fcd0e787c/Sacha.org#org-agenda][this =delq= and =mapcar= trick from Sacha Chua's config]].

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files
      (delq nil
            (mapcar (lambda (x) (and (file-exists-p x) x))
                    '("~/Dropbox/todo.org"
                      "~/Dropbox/cbsr_todo.org"))))
#+END_SRC

*** Org capture

#+BEGIN_SRC emacs-lisp
(bind-key "C-c c" 'org-capture)
(setq org-default-notes-file "~/Dropbox/notes.org")
#+END_SRC

*** Org setup

Speed commands are a nice and quick way to perform certain actions
while at the beginning of a heading. It's not activated by default.

See the doc for speed keys by checking out [[elisp:(info%20"(org)%20speed%20keys")][the documentation for
speed keys in Org mode]].

#+BEGIN_SRC emacs-lisp
(setq org-use-speed-commands t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-image-actual-width 550)
#+END_SRC

*** Org tags

The default value is -77, which is weird for smaller width windows.
I'd rather have the tags align horizontally with the header. 45 is a
good column number to do that.

#+BEGIN_SRC emacs-lisp
(setq org-tags-column 45)
#+END_SRC

*** Org babel languages

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   (C . t)
   (calc . t)
   (latex . t)
   (java . t)
   (ruby . t)
   (scheme . t)
   (sh . t)
   (sqlite . t)
   (js . t)))

(defun my-org-confirm-babel-evaluate (lang body)
  "Do not confirm evaluation for these languages."
  (not (or (string= lang "C")
           (string= lang "java")
           (string= lang "python")
           (string= lang "emacs-lisp")
           (string= lang "sqlite"))))
(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
#+END_SRC

*** Org babel/source blocks

Have source blocks properly syntax highlighted and with the editing
popup window staying within the same window so all the windows don't
jump around. Also, having the top and bottom trailing lines in the
block is a waste of space, so we can remove them.

Fontification doesn't work with markdown mode when the block is
indented after editing it in the org src buffer---the leading #s for
headers don't get fontified properly because they appear as Org
comments.

#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'current-window
      org-src-strip-leading-and-trailing-blank-lines t
      org-src-tab-acts-natively t)
#+END_SRC

** =re-builder=

Interactive preview for RE construction.

It's important to note that there's three flavours of regular
expressions encountered in Emacs.  The =read= syntax is most
reminiscent of other RE dialects, but only used in prompts.  The
=string= syntax is used in code doubles the amount of backslashes as
the RE strings are passed through the reader which removes the
extraneous ones.  Finally, there's the ~rx~ macro one can use for
writing lispy RE.

All listed RE syntaxes are supported by =re-builder=. For whatever
reason though the =read= syntax is default. I prefer having the
=string= syntax as default.

#+BEGIN_SRC emacs-lisp
(setq reb-re-syntax 'string)
#+END_SRC

** =recentf=

Recentf is a minor mode that builds a list of recently opened files.
This list is is automatically saved across Emacs sessions.

Prefer saving the history of opened files somewhere other than the default.

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :init
    (setq recentf-save-file "~/.emacs.d/etc/recentf")
  :config
    (recentf-mode 1)
    (setq recentf-max-saved-items 100))
#+END_SRC

** =savehist=

The history of prompts like =M-:= can be saved, but let's change its
save file and history length first. Also save search entries.

#+BEGIN_SRC emacs-lisp
(setq savehist-additional-variables '(search-ring regexp-search-ring)
      savehist-file "~/.emacs.d/etc/savehist"
      history-length 150)
(savehist-mode)
#+END_SRC

** =save-place=

Remember position in a file.

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :init
    (setq save-place-file "~/.emacs.d/etc/saveplace"
          save-place-forget-unreadable-files nil)
    (setq-default save-place t))
#+END_SRC

** =shell=

#+BEGIN_SRC emacs-lisp
(bind-key "C-x m" 'shell)
(bind-key "C-x M" 'ansi-term)
#+END_SRC

** =tramp=

#+BEGIN_SRC emacs-lisp
(use-package tramp
  :init (setq tramp-ssh-controlmaster-options ""))
#+END_SRC

** =windmove=

=windmove= provides useful commands for moving window focus by
direction.

#+BEGIN_SRC emacs-lisp
(windmove-default-keybindings 'meta)
#+END_SRC

** =winner-mode=

Window management. ~C-c left (winner-undo)~ undoes the last window
configuration change. Redo the changes using ~C-c right
(winner-redo)~. Also move from window to window using Meta and the
direction keys.

#+BEGIN_SRC emacs-lisp
(winner-mode t)
#+END_SRC

** =whitespace=

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :bind ("S-<f10>" . whitespace-mode))
#+END_SRC

* ELPA packages

These are the packages that are not built into Emacs.

** [[https://github.com/Wilfred/ag.el][ag]]

Use silver surfer to search.

#+BEGIN_SRC emacs-lisp
(use-package ag
  :commands ag
  :ensure t)
#+END_SRC

** [[https://github.com/abo-abo/ace-window][ace-window]]

A package that uses the same idea from ace-jump-mode for
buffer navigation, but applies it to windows. The default keys are
1-9, but it's faster to access the keys on the home row, so that's
what I have them set to (with respect to Dvorak, of course).

#+BEGIN_SRC emacs-lisp
(use-package ace-window)
#+END_SRC

** [[https://github.com/syohex/emacs-anzu][anzu]]

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :ensure t
  :bind
  (([remap query-replace] . anzu-query-replace)
   ([remap query-replace-regexp] . anzu-query-replace-regexp))
  :config
  (global-anzu-mode +1)
  (set-face-attribute 'anzu-mode-line nil
                      :foreground "yellow" :weight 'bold)
  (custom-set-variables
   '(anzu-mode-lighter "")
   '(anzu-deactivate-region t)
   '(anzu-search-threshold 1000)
   '(anzu-replace-threshold 50)
   '(anzu-replace-to-string-separator " => ")))
#+END_SRC

** [[https://github.com/abo-abo/avy][avy]]

A quick way to jump around text in buffers.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :bind
  (("C-c SPC" . avy-goto-char)
   ("C-'" . avy-goto-char-2)
   ("M-g M-g" . avy-goto-line)))
#+END_SRC

** [[https://github.com/belak/base16-emacs][base16-emacs]]

One tweak to the base16-google-dark theme; the face for the mode line
buffer name is too hard to see,  set it to white instead.

#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :ensure t
  :config
    ;;(load-theme 'base16-solarized-dark t)
    (load-theme 'base16-google-dark t)
    (set-face-attribute 'mode-line-buffer-id nil :foreground "white")
    )
#+END_SRC
** [[https://github.com/Malabarba/beacon][beacon]]

Never lose your cursor again

#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :init
    (setq beacon-push-mark 35)
    (setq beacon-color "#666600")
  :config (beacon-mode 1)
  )
#+END_SRC

** [[https://github.com/jorgenschaefer/circe][circe]]

#+BEGIN_SRC emacs-lisp :tangle no
(use-package circe
  :ensure t
  :config (setq circe-default-nick "chucho"
                circe-default-user "chucho"
                circe-default-realname "chucho"
                circe-default-part-message "Bye"
                circe-default-quit-message "Bye"
                circe-network-options '(("Freenode"
                                         :tls t
                                         :channels ("#emacs")
                                         ))))
#+END_SRC

** [[https://github.com/bburns/clipmon][clipmon]]

#+BEGIN_SRC emacs-lisp
(use-package clipmon
  :ensure t
  :commands clipmon-mode-start
  :bind ("M-S-<f2>" . clipmon-autoinsert-toggle)
  :config
  (clipmon-mode-start))
#+END_SRC

** [[https://github.com/ankurdave/color-identifiers-mode][color-identifiers]]

Color Identifiers is a minor mode for Emacs that highlights each source code identifier uniquely
based on its name.

#+BEGIN_SRC emacs-lisp
(use-package color-identifiers-mode
  :ensure t
  :diminish color-identifiers-mode
  :config
    (add-hook 'after-init-hook 'global-color-identifiers-mode)
    (set-face-attribute 'font-lock-comment-delimiter-face nil :slant 'italic)
    (set-face-attribute 'font-lock-comment-face nil :slant 'italic))
#+END_SRC

** [[https://github.com/company-mode/company-mode][company-mode]]

Complete anything.

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :diminish company-mode
  :bind
  ("M-/" . company-complete-common)
  :config
  (add-hook 'after-init-hook 'global-company-mode))

(use-package company-tern)
#+END_SRC

** [[https://github.com/thamer/diredful][diredful]]

#+BEGIN_SRC emacs-lisp
(use-package diredful
  :ensure t
  :config (diredful-mode 1))
#+END_SRC

** [[https://github.com/jacktasia/dumb-jump/blob/master/README.md][dumb-jump]]

#+BEGIN_QUOTE
Dumb Jump is an Emacs "jump to definition" package with support for
multiple programming languages that favors "just working". This means
minimal -- and ideally zero -- configuration with absolutely no stored
indexes (TAGS) or persistent background processes.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :ensure t)

#+END_SRC

** [[https://github.com/senny/emacs-eclim][emacs-eclim]]

Provides Emacs with some Eclipse features for Java development. Eclim has to be installed first and
can be downloaded from [[http://eclim.org/install.html][here]].

#+BEGIN_SRC emacs-lisp
(use-package company-emacs-eclim
  :ensure t
  :commands company-emacs-eclim-setup)
(use-package eclimd
  :load-path "/home/nelson/src/github/elisp/emacs-eclim"
  :commands start-eclimd
  :config
  (custom-set-variables
    '(eclimd-autostart nil)))
(use-package eclim
  :load-path "/home/nelson/src/github/elisp/emacs-eclim"
  :diminish eclim-mode
  :commands (global-eclim-mode)
  :init (use-package cl)
  :config
    (let ((eclipse-dir (expand-file-name "~/apps/eclipse/java/neon/eclipse")))
      (if (file-accessible-directory-p eclipse-dir)
          (progn
            (add-to-list 'eclim-eclipse-dirs eclipse-dir)
            (setq eclim-executable (or (concat eclipse-dir "/eclim") (executable-find "eclim"))
                  eclimd-executable (or (concat eclipse-dir "/eclimd") (executable-find "eclimd"))
                  ))))
    (company-emacs-eclim-setup)
    (global-company-mode t)
    (setq eclim-auto-save t
          eclimd-wait-for-process nil
          eclimd-default-workspace "~/workspace/"
          help-at-pt-display-when-idle t
          help-at-pt-timer-delay 0.1

          )
    ;; Call the help framework with the settings above & activate eclim-mode
    (help-at-pt-set-timer)

    ;; keep consistent which other auto-complete backend.
    (custom-set-faces
     '(ac-emacs-eclim-candidate-face ((t (:inherit ac-candidate-face))))
     '(ac-emacs-eclim-selection-face ((t (:inherit ac-selection-face))))))
#+END_SRC

** [[https://github.com/chrisbarrett/emacs-refactor][emacs-refactor]]

#+BEGIN_SRC emacs-lisp
(use-package emr
  :ensure t
  :bind (:map prog-mode-map
              ("M-RET" . emr-show-refactor-menu))
  :config (emr-initialize))
#+END_SRC

** [[https://github.com/ensime/ensime-emacs][ensime-emacs]]

#+BEGIN_SRC emacs-lisp :tangle no
(use-package ensime
  :ensure t
  :commands ensime ensime-mode))
#+END_SRC

** [[https://github.com/jacobono/emacs-gradle-mode][emacs-gradle-mode]]

#+BEGIN_SRC emacs-lisp
(use-package gradle-mode
  :ensure t
  :diminish gradle-mode
  :init
    (gradle-mode 1))
#+END_SRC

** [[https://github.com/magnars/expand-region.el][expand-region]]

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind ("C-=" . er/expand-region)
  :config (setq expand-region-smart-cursor t))
#+END_SRC

** [[http://www.emacswiki.org/emacs/fic-mode.el][fic-mode]]

Show FIXME/TODO/BUG/KLUDGE in special face only in comments and
strings.

#+BEGIN_SRC emacs-lisp
(use-package fic-mode
  :ensure t
  :commands fic-mode
  :config
    (add-hook 'c++-mode-hook 'fic-mode)
    (add-hook 'c-mode-hook 'fic-mode)
    (add-hook 'java-mode-hook 'fic-mode)
    (add-hook 'vala-mode-hook 'fic-mode)
    (add-hook 'python-mode-hook 'fic-mode))
#+END_SRC

** [[http://www.emacswiki.org/emacs/framemove.el][framemove]]

Allow windmove to jump between frames.

#+BEGIN_SRC emacs-lisp
(use-package framemove
  :ensure t
  :config
  (setq framemove-hook-into-windmove t))
#+END_SRC

** [[https://github.com/flycheck/flycheck][flycheck]]

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :diminish flycheck-mode
  :config
  (add-hook 'after-init-hook #'global-flycheck-mode)
  (setq flycheck-standard-error-navigation nil)

  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint)))

  (setq flycheck-checkers '(javascript-eslint))
  ;; use eslint with web-mode for jsx files
  (flycheck-add-mode 'javascript-eslint 'web-mode)
  (flycheck-add-mode 'javascript-eslint 'js2-mode)
  (flycheck-add-mode 'javascript-eslint 'js-mode))
#+END_SRC

** [[https://github.com/lbolla/emacs-flycheck-flow][emacs-flycheck-flow]]

This package adds support for flow to flycheck.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package flycheck-flow
  :ensure t
  :config
  (add-hook 'js2-mode-hook 'flycheck-mode))
#+END_SRC


** [[https://github.com/mola-T/flymd][flymd]]

On the fly markdown preview.

#+BEGIN_SRC emacs-lisp :tangle no
(defun my-flymd-browser-function (url)
  (let ((browse-url-browser-function 'browse-url-firefox))
    (browse-url url)))

(use-package flymd
  :ensure t
  :config
  (setq flymd-browser-open-function 'my-flymd-browser-function))
#+END_SRC

** [[https://github.com/leoliu/ggtags][ggtags]]

Generate tags on command line with ~gtags~.
Updte tags on command line with ~global -u~.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package ggtags
  :ensure t
  :commands ggtags-mode)
#+END_SRC

** [[https://github.com/pidu/git-timemachine][git-timemachine]]

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :ensure t
  :commands git-timemachine)
#+END_SRC

** [[https://github.com/camdez/goto-last-change.el][goto-last-change]]

#+BEGIN_SRC emacs-lisp
(use-package goto-last-change
  :ensure t
  :bind
  ("C-x C-\\" . goto-last-change)
  :config
  (autoload 'goto-last-change "goto-last-change"
    "Set point to the position of the last change." t))
#+END_SRC

** [[https://github.com/Groovy-Emacs-Modes/groovy-emacs-modes][groovy-mode]]

Required for gradle build files.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package groovy-mode
  :ensure t)
#+END_SRC

** [[*][grunt]]

#+BEGIN_SRC emacs-lisp
(use-package grunt
  :ensure t)
#+END_SRC

** [[https://github.com/kai2nenobu/guide-key][guide-key]]

Guide the following key bindings automatically and dynamically.

#+BEGIN_SRC emacs-lisp
(use-package guide-key
  :ensure t
  :diminish guide-key-mode
  :config
    (setq guide-key/guide-key-sequence '("C-x r" "C-c p" "C-h" "C-c h"))
    (guide-key-mode 1))
#+END_SRC

** [[https://github.com/emacs-helm/helm][helm]]
*** Helm Config

GNU Global and projectile: use ~C-c p R~ to regenerate tag file.

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :commands (helm-config helm-eshell helm-files helm-grep)
  :diminish helm-mode
  :init
    ;; must set before helm-config, otherwise helm uses the default
    ;; prefix "C-x c", which is inconvenient because you can
    ;; accidentially press "C-x C-c"
    (setq helm-command-prefix-key "C-c h")
    (helm-flx-mode +1)
    (setq helm-split-window-in-side-p t           ; open helm buffer inside current window,
          ;; not occupy whole other window
          helm-ff-newfile-prompt-p nil
          ;;helm-google-suggest-use-curl-p t        ; helm-M-x-fuzzy-match t ; using flx for now
          helm-scroll-amount 4                    ; scroll 4 lines other window using
          ;; M-<next>/M-<prior>
          ;;helm-quick-update t                     ; do not display invisible candidates
          ;;helm-idle-delay 0.01                    ; be idle for this many seconds, before
          ;; updating in delayed sources.
          ;;helm-input-idle-delay 0.01              ; be idle for this many seconds, before
          ;; updating candidate buffer
          helm-ff-search-library-in-sexp t        ; search for library in `require` and
          ;; `declare-function` sexp.

          ;;helm-buffers-favorite-modes (append helm-buffers-favorite-modes
          ;;                                    '(picture-mode artist-mode))
          ;; limit the number of displayed canidates
          ;;helm-candidate-number-limit 100
          ;; show all candidates when set to 0
          ;;helm-M-x-requires-pattern 0
          helm-ff-file-name-history-use-recentf t
          ;; move to end or beginning of source when reaching top or bottom of source.
          helm-move-to-line-cycle-in-source t
          ;; Needed in helm-buffers-list
          ;;ido-use-virtual-buffers t
          ;; fuzzy matching buffer names when non--nil, useful in helm-mini that lists buffers
          ;;helm-buffers-fuzzy-matching t
          ;; truncate long lines
          ;;helm-truncate-lines t
          helm-autoresize-min-height 30
          helm-autoresize-max-height 30
          helm-display-header-line nil
          helm-buffer-max-length 45
          helm-yas-display-key-on-candidate t)

    ;; Save current position to mark ring when jumping to a different place
    (add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)
    (helm-mode)
    (helm-autoresize-mode 1)
    (custom-set-variables '(helm-ag-use-temp-buffer nil)) ; setting to 't' does not work with js2-mode
  :bind (("M-x" . helm-M-x)
         ("M-y" . helm-show-kill-ring)
         ("C-x b" . helm-mini)
         ("C-x C-f" . helm-find-files)
         ("C-`" . helm-resume)))
#+END_SRC

*** Helm Search

[[http://www.gnu.org/software/grep/][grep]] is very fast, but not the best tool for code search, especially
not within compressed files. That's why I'll go for [[https://github.com/ggreer/the_silver_searcher/][ag]] instead, its
=-z= option enables the usage of the very great [[http://libarchive.org/][libarchive]]. For =helm=
to recognize the matches properly I need to enable line numbers and
columns in its output, something the =--vimgrep== option (the irony)
does. Another subtle hack hidden in here is deliberately using the
recursing variant for both types of searches, this might break
something, but so far hasn't shown any obvious side-effects

#+BEGIN_SRC emacs-lisp
(setq helm-grep-default-command "ag --vimgrep -z %p %f"
      helm-grep-default-recurse-command "ag --vimgrep -z %p %f")
#+END_SRC

*** Helm Key bindings

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'helm-files
  ;; rebind tab to do persistent action
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  ;; make TAB works in terminal
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
  ;; list actions using C-z
  (define-key helm-map (kbd "C-z")  'helm-select-action)
  (define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
  (define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
  (define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward))
#+END_SRC

*** Helm Window config

(NOT WORKING) So that helm windows shows at the bottom.

- from http://www.reddit.com/r/emacs/comments/345vtl/make_helm_window_at_the_bottom_without_using_any/
- see also http://www.lunaryorn.com/2015/04/29/the-power-of-display-buffer-alist.html

#+BEGIN_SRC emacs-lisp :tangle no
(with-eval-after-load 'helm
  (cond (window-system
         (add-to-list 'display-buffer-alist
                      `("^\\*[Hh]elm"
                        (display-buffer-in-side-window)
                        (inhibit-same-window . nil)
                        (reusable-frames . visible)
                        (side            . bottom)
                        (window-height   . 0.15)))
         )))
#+END_SRC

*** Helm Other

Highlighting of token matches is a tad slow, let's speed it up.

#+BEGIN_SRC emacs-lisp
(setq helm-mp-highlight-delay 0.3)
#+END_SRC

I don't know why, but helm tries doing window management.  Please
stop:

#+BEGIN_SRC emacs-lisp
(setq helm-display-function 'pop-to-buffer)
#+END_SRC

** [[https://github.com/syohex/emacs-helm-ag][helm-ag]]

#+BEGIN_SRC emacs-lisp
(use-package helm-ag
  :ensure t
  :commands helm-ag)
#+END_SRC

** [[https://github.com/emacs-jp/helm-c-yasnippet][helm-c-yasnippet]]

#+BEGIN_SRC emacs-lisp
(use-package helm-c-yasnippet
  :ensure t
  :commands helm-yas-complete
  ;;:init (use-package yasnippet)
  :bind ("C-c y" . helm-yas-complete))
#+END_SRC

** [[https://github.com/PythonNut/helm-flx][helm-flx]]

#+BEGIN_SRC emacs-lisp :tangle no
(use-package helm-flx
  :ensure t
  :commands helm-flx-mode
  :init
    (helm-flx-mode +1)

    ;; From: https://github.com/hatschipuh/helm-better-defaults
    ;;
    (defun my-helm-make-source (f &rest args)
      (nconc args '(:fuzzy-match t))
      (apply f args))

    (advice-add 'helm-make-source :around 'my-helm-make-source)
    ;;
    ;; garbage collections
    (defun my-minibuffer-setup-hook ()
      (setq gc-cons-threshold most-positive-fixnum))

    (defun my-minibuffer-exit-hook ()
      (setq gc-cons-threshold 800000))

    (add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
    (add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook))
#+END_SRC

** [[https://github.com/syohex/emacs-helm-gtags][helm-gtags]]

#+BEGIN_SRC emacs-lisp :tangle no
(use-package helm-gtags
  :ensure t
  :commands (helm-gtags-mode)
  :bind (("M-." . helm-gtags-find-tag)
         ("M-," . helm-gtags-find-rtag))
  :config
  (custom-set-variables
   '(helm-gtags-path-style 'relative)
   '(helm-gtags-ignore-case t)
   '(helm-gtags-auto-update t)))
#+END_SRC

** [[https://github.com/bbatsov/projectile][helm-projectile]]

#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :ensure t
  ;;:bind (("C-c p h" . helm-projectile))
  :config
    (helm-projectile-on)
    (setq compilation-read-command t)) ; do prompt for a compilation command
#+END_SRC

** [[https://github.com/ShingoFukuyama/helm-swoop][helm-swoop]]

#+BEGIN_SRC emacs-lisp :tangle no
(use-package helm-swoop
  :ensure t
  :bind (("M-i" . helm-swoop))
  :config
    ;; When doing isearch, hand the word over to helm-swoop
    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    ;; From helm-swoop to helm-multi-swoop-all
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
    ;; Move up and down like isearch
    (define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
    (define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
    (define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
    (define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)
    ;; Save buffer when helm-multi-swoop-edit complete
    (setq helm-multi-swoop-edit-save t
          ;; If this value is t, split window inside the current window
          helm-swoop-split-with-multiple-windows nil
          ;; Optional face for line numbers
          ;; Face name is `helm-swoop-line-number-face`
          helm-swoop-use-line-number-face t))
#+END_SRC

** [[https://github.com/DarthFennec/highlight-indent-guides][highlight-indent-guides]]

#+BEGIN_QUOTE
This minor mode highlights indentation levels via =font-lock=.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :ensure t
  :config
  (setq highlight-indent-guides-method 'character)
  (set-face-foreground 'highlight-indent-guides-character-face "gray18")
  (add-hook 'prog-mode-hook 'highlight-indent-guides-mode))
#+END_SRC

** [[https://github.com/boyw165/hl-anything][hl-anything]]

Not used for now since it breaks ERC font lock.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package hl-anything
  :ensure t
  :config
    (hl-highlight-mode 1)
    ;; (hl-setup-default-advices nil)
    ;; (hl-setup-customizable-advices nil)
    ;; (remove-hook 'kill-emacs-hook 'hl-save-highlights)
    )
#+END_SRC

** [[https://github.com/nflath/hungry-delete][hungry-delete]]

So that hungry deletion can be used in all modes.

#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
  :ensure t
  :config
  (global-hungry-delete-mode))
#+END_SRC

** [[https://github.com/abo-abo/hydra][hydra]]

This package can be used to tie related commands into a family of
short bindings with a common prefix - a Hydra.

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t
  :init
  (use-package cl-lib)
  (use-package lv)
  (use-package ace-window :ensure t)
  (use-package avy :ensure t)
  (use-package key-chord
    :ensure t
    :config (key-chord-mode 1))
  :config
  ;; http://oremacs.com/2015/01/29/more-hydra-goodness/

  (defun hydra-universal-argument (arg)
    (interactive "P")
    (setq prefix-arg (if (consp arg)
                         (list (* 4 (car arg)))
                       (if (eq arg '-)
                           (list -4)
                         '(4)))))

  (defhydra hydra-window (global-map "C-M-o")
    "window"
    ("h" windmove-left "left")
    ("j" windmove-down "down")
    ("k" windmove-up "up")
    ("l" windmove-right "right")
    ("a" ace-window "ace")
    ("u" hydra-universal-argument "universal")
    ("s" (lambda nil (interactive) (ace-window 4)) "swap")
    ("d" (lambda nil (interactive) (ace-window 16)) "delete"))

  (key-chord-define-global "yy" 'hydra-window/body)

;; for better next-buffer and previous-buffer see http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html

  (defhydra hydra-buffer (:color blue :columns 3)
    "
                Buffers :
    "
    ("n" next-buffer "next" :color red)
    ("b" helm-mini "switch")
    ("B" ibuffer "ibuffer")
    ("p" previous-buffer "prev" :color red)
    ("C-b" buffer-menu "buffer menu")
    ("d" kill-this-buffer "delete" :color red)
    ;; don't come back to previous buffer after delete
    ("D" (progn (kill-this-buffer) (next-buffer)) "Delete" :color red)
    ("s" save-buffer "save" :color red))

  (key-chord-define-global "zz" 'hydra-buffer/body))
#+END_SRC

** [[https://github.com/abo-abo/swiper][ivy]]

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :diminish (ivy-mode . "")
  :bind
  (:map ivy-mode-map
   ("C-'" . ivy-avy))
  :config
  (ivy-mode 1)
  ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
  (setq ivy-use-virtual-buffers t)
  ;; number of result lines to display
  (setq ivy-height 10)
  ;; does not count candidates
  (setq ivy-count-format "")
  ;; no regexp by default
  (setq ivy-initial-inputs-alist nil)
  ;; configure regexp engine.
  (setq ivy-re-builders-alist
        ;; allow input not in order
        '((t . ivy--regex-ignore-order))))

(use-package ivy-hydra
  :ensure t)
#+END_SRC

*** [[https://github.com/abo-abo/swiper][swiper]]

This blog post has a lot of info: [[http://oremacs.com/2016/04/26/ivy-0.8.0/][Ivy 0.8.0 is out]]

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :bind (("C-s" . swiper)
         ("C-c C-r" . ivy-resume)
         ("<f6>" . ivy-resume))
  :config
  (ivy-mode 1)
  (setq ivy-initial-inputs-alist nil)
  (setq ivy-use-virtual-buffers t)
  (setq swiper-action-recenter t))
#+END_SRC

Also, install counsel:

See this article for recentering: [[http://manuel-uberti.github.io/emacs/2016/05/30/swiperrecenter/][Recentre the buffer when leaving Swiper]].

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  :bind (;;("C-x C-f" . counsel-find-file)
         ;;("M-y" . counsel-yank-pop)
         ("C-h f" . counsel-describe-function)
         ("C-h v" . counsel-describe-variable)
         ("C-c s a" . counsel-ag)))
#+END_SRC

When using =counsel-ag=:
- use ~C-c C-o~ (=ivy-occur) to save results to a buffer,
- use ~C-x C-q~ (=ivy-wgrep-change-to-wgrep-mode=) to edit the buffer,
- use ~C-x C-s~ to save the changes, or
- use ~C-c C-k~ to abort all changes

** [[https://github.com/mooz/js2-mode][js2-mode]]

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :commands (js2-mode)
  :mode "\\.js\\'"
  :init
  (setq js2-global-externs '("define"
                             "jasmine"
                             "describe"
                             "fdescribe"
                             "fail"
                             "beforeEach"
                             "afterEach"
                             "inject"
                             "expect"
                             "spyOn"
                             "it"
                             "fit"
                             "xit"))
  :config
  (custom-set-variables '(js2-basic-offset 2)
                        '(js2-bounce-indent-p nil)
                        '(js2-highlight-level 3))

  ;;(eval-after-load 'js2-mode
  ;;  '(define-key js2-mode-map (kbd "RET") 'js2-line-break))

  ;;(add-hook 'js2-mode-hook 'ac-js2-mode)
  ;;(setq ac-js2-evaluate-calls t)

  (setq-default js2-mode-show-parse-errors t)
  (setq-default js2-strict-missing-semi-warning t)
  (setq-default js2-strict-trailing-comma-warning t))
#+END_SRC

** [[https://github.com/magnars/js2-refactor.el][js2-refactor]]

#+BEGIN_SRC emacs-lisp
(use-package js2-refactor
  :ensure t
  :after js2-mode
  :diminish js2-refactor-mode
  :config
  (add-hook 'js-mode-hook #'js2-refactor-mode)
  (js2r-add-keybindings-with-prefix "C-c C-m"))
#+END_SRC

** [[https://github.com/tonini/karma.el][karma]]

#+BEGIN_SRC emacs-lisp
(use-package karma
  :ensure t
  :commands karma-mode)
#+END_SRC

** [[https://github.com/purcell/less-css-mode][less-css-mode]]

#+BEGIN_SRC emacs-lisp
(use-package less-css-mode
  :ensure t
  :commands less-css-mode)
#+END_SRC

** [[https://github.com/jschaf/emacs-lorem-ipsum][lorem-ipsum]]

Add filler lorem ipsum text to Emacs.

#+BEGIN_SRC emacs-lisp
(use-package lorem-ipsum
  :ensure t)
#+END_SRC

** [[https://github.com/joddie/macrostep][macrostep]]

Macrostep allows you to see what Elisp macros expand to. Learned about
it from the [[https://www.youtube.com/watch?v%3D2TSKxxYEbII][package highlight talk for use-package]].

#+BEGIN_SRC emacs-lisp
(use-package macrostep
  :ensure t)
#+END_SRC

** [[https://github.com/magit/magit][magit]]

A great interface for git projects. It's much more pleasant to use than the git interface on the
command line. Use an easy keybinding to access magit.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("C-x g" . magit-status))
  :config
  (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
  (setq magit-push-always-verify nil))
#+END_SRC

*** Performance

Turn this off for better perfomance since we are using Magit.

#+BEGIN_SRC emacs-lisp
(setq vc-handled-backends nil)
#+END_SRC

*** Fullscreen magit

#+BEGIN_QUOTE
The following code makes magit-status run alone in the frame, and then restores the old window
configuration when you quit out of magit.

No more juggling windows after commiting. It's magit bliss.
#+END_QUOTE
[[http://whattheemacsd.com/setup-magit.el-01.html][Source: Magnar Sveen]]

#+BEGIN_SRC emacs-lisp
;; full screen magit-status
(defadvice magit-status (around magit-fullscreen activate)
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))

(defun magit-quit-session ()
  "Restores the previous window configuration and kills the magit buffer"
  (interactive)
  (kill-buffer)
  (jump-to-register :magit-fullscreen))
#+END_SRC

** [[https://github.com/defunkt/markdown-mode][markdown-mode]]

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.markdown\\'" . markdown-mode)
         ("\\.md\\'"       . markdown-mode))
  :config
  (add-hook 'markdown-mode-hook
            (lambda () (auto-fill-mode -1)))
  :init
  (setq markdown-command "marked"))
#+END_SRC

** [[https://github.com/oneKelvinSmith/monokai-emacs][monokai-emacs]]

TextMate like theme.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package monokai-theme
  :ensure t
  :config
    (load-theme 'monokai t)
    (setq frame-background-mode `dark)
    (setq monokai-use-variable-pitch nil))
#+END_SRC

** [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]

We'll also need to ~(require 'multiple-cusors)~ because of [[https://github.com/magnars/multiple-cursors.el/issues/105][an autoload issue]].

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :init (require 'multiple-cursors)
  :bind (("C-S-c C-S-c" . mc/edit-lines)
         ("C->"         . mc/mark-next-like-this)
         ("C-<"         . mc/mark-previous-like-this)
         ("C-M->"       . mc/unmark-next-like-this)
         ("C-M-<"       . mc/unmark-previous-like-this)
         ("C-c C-<"     . mc/mark-all-like-this)
         ("C-!"         . mc/mark-next-symbol-like-this)
         ("C-x C-m"     . mc/mark-all-dwim)))
#+END_SRC

** [[https://github.com/nex3/perspective-el][perspective]]

This package provides tagged workspaces.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package perspective
  :ensure t
  :config (persp-mode))
#+END_SRC

** [[https://github.com/bbatsov/projectile][projectile]]

#+BEGIN_QUOTE
Project navigation and management library for Emacs.
#+END_QUOTE
http://batsov.com/projectile/


#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :commands projectile-mode
  :config
  (setq projectile-indexing-method 'alien
        projectile-remember-window-configs nil
        projectile-switch-project-action 'projectile-dired
        projectile-completion-system 'default
        projectile-enable-caching nil
        projectile-create-missing-test-files t)

  (projectile-global-mode)
  (setq projectile-completion-system 'helm)

  (def-projectile-commander-method ?d
    "Open project root in dired."
    (projectile-dired)))
#+END_SRC

** [[https://github.com/google/protobuf][protobuf]]

#+BEGIN_SRC emacs-lisp
(use-package protobuf-mode
  :ensure t
  :config
  (defconst my-protobuf-style
    '((c-basic-offset . 2)
      (indent-tabs-mode . nil)))
  (add-hook 'protobuf-mode-hook
            (lambda ()
              (c-add-style "my-style" my-protobuf-style t)
              (subword-mode 1))))
#+END_SRC

** [[https://github.com/milkypostman/powerline][powerline]]

#+BEGIN_SRC emacs-lisp :tangle no
(use-package powerline
  :ensure t
  :config
    (setq powerline-arrow-shape 'arrow14)
    (setq powerline-default-separator-dir '(right . left))

    (custom-set-faces
     '(mode-line ((t (:foreground "#030303" :background "#6b6b6b" :box nil))))
     '(mode-line-inactive ((t (:foreground "#f9f9f9" :background "#6b6b6b" :box nil)))))

    (setq powerline-color1 "#49483E")
    (setq powerline-color2 "#333333")
    (powerline-default-theme))
#+END_SRC

** [[https://github.com/bmag/helm-purpose][purpose]]

#+BEGIN_SRC emacs-lisp :tangle no
(use-package window-purpose
  :ensure t
  :commands purpose-mode
  :config
    (add-to-list 'purpose-user-mode-purposes '(scala-mode . scala))
    (add-to-list 'purpose-user-mode-purposes '(sbt-mode . scala))
    (purpose-compile-user-configuration))
#+END_SRC

** [[https://melpa.org/#/python-mode][python-mode]]

Integrates with IPython.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package python-mode
    :ensure t)
#+END_SRC

** [[https://github.com/sabof/org-bullets][org-bullets]]

#+BEGIN_QUOTE
Show org-mode bullets as UTF-8 characters.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

** [[https://github.com/emacsmirror/revive][revive]]

Using revive

- use ~M-x save-current-configuration~ to save window configuration.
- use ~M-x resume~ to load window configuration.

#+BEGIN_SRC emacs-lisp
(use-package revive
  :ensure t)
#+END_SRC

** [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]]

Highlight brackets according to their depth

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :commands rainbow-delimiters-mode
  :init
    (add-hook 'prog-mode-hook (lambda () (rainbow-delimiters-mode t))))
#+END_SRC

** [[https://github.com/fgallina/region-bindings-mode][region-bindings-mode]]

Disable for now since causing issues when I use region expand and want
to overwrite.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package region-bindings-mode
  :ensure t
  :config
  (region-bindings-mode-enable)
  (define-key region-bindings-mode-map "a" 'mc/mark-all-like-this)
  (define-key region-bindings-mode-map "p" 'mc/mark-previous-like-this)
  (define-key region-bindings-mode-map "n" 'mc/mark-next-like-this)
  (define-key region-bindings-mode-map "m" 'mc/mark-more-like-this-extended)
  (define-key region-bindings-mode-map "q" 'anzu-query-replace-regexp)
  (define-key region-bindings-mode-map "w" 'whole-line-or-region-kill-ring-save))
#+END_SRC

** [[https://github.com/slime/slime][slime]]

#+BEGIN_QUOTE
SLIME is the Superior Lisp Interaction Mode for Emacs.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package slime
  :ensure t
  :config
  (setq inferior-lisp-program "/home/nelson/apps/clozureCL/ccl/lx86cl64")
  (setq slime-contribs '(slime-fancy)))
#+END_SRC

** [[https://github.com/ieure/scratch-el][scratch]]

Convenient package to create =*scratch*= buffers that are based on the current buffer's major mode.
This is more convienent than manually creating a buffer to do some scratch work or reusing the
initial =*scratch*= buffer.

#+BEGIN_SRC emacs-lisp
(use-package scratch
  :ensure t)
#+END_SRC

** [[https://github.com/wasamasa/shackle][shackle]]

#+BEGIN_QUOTE
Declarative popup window rules.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package shackle
  :ensure t
  :config
    (setq shackle-rules
          '(("*Help*" :align t :ratio 0.4 :select t)
            ("\\`\\*[Hh]elm.*?\\*\\'" :regexp t :align 'bottom :ratio 0.4)
            ;;("\\*sbt\\*.*" :regexp t :other t)
            ("\\*sbt\\*.*" :regexp t :other t)
            ;;(compilation-mode :popup t)
            (("*shell*" "*eshell*") :popup t))
          shackle-default-rule '(:select t)
          shackle-inhibit-window-quit-on-same-windows t)
    (shackle-mode))
#+END_SRC

** [[https://github.com/Fuco1/smartparens][smartparens]]

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :diminish smartparens-mode
  :config
  (require 'smartparens-config)
  (smartparens-global-mode t))
#+END_SRC


*** Smartparens org mode

Set up some pairings for org mode markup. These pairings won't
activate by default; they'll only apply for wrapping regions.

#+BEGIN_SRC emacs-lisp
(sp-local-pair 'org-mode "~" "~" :actions '(wrap))
(sp-local-pair 'org-mode "/" "/" :actions '(wrap))
(sp-local-pair 'org-mode "*" "*" :actions '(wrap))
#+END_SRC

** [[https://github.com/mickeynp/smart-scan][smart-scan]]

Quickly jumps between other symbols found at point in Emacs.
http://www.masteringemacs.org/article/smart-scan-jump-symbols-buffer

#+BEGIN_SRC emacs-lisp
(use-package smartscan
  :ensure t
  :config (global-smartscan-mode 1))
#+END_SRC

** [[https://github.com/jbondeson/smooth-scrolling][smooth-scrolling]]

#+BEGIN_SRC emacs-lisp
(use-package smooth-scrolling
  :ensure t
  :config (setq smooth-scroll-margin 6))
#+END_SRC

** [[https://github.com/bbatsov/solarized-emacs][solarized-emacs]]

#+BEGIN_SRC emacs-lisp :tangle no
(use-package solarized-theme
  :ensure t
  :config
    (load-theme 'solarized-dark t))
#+END_SRC

** [[https://github.com/TheBB/spaceline][spaceline]]

#+BEGIN_SRC emacs-lisp
(use-package spaceline :ensure t)
(use-package spaceline-config
  :ensure nil
  :after spaceline
  :config
  (setq-default powerline-default-separator 'wave
                powerline-height 18
                spaceline-highlight-face-func 'spaceline-highlight-face-modified)
  (spaceline-toggle-persp-name-off)
  (spaceline-toggle-workspace-number-off)
  (spaceline-toggle-version-control-on)
  (spaceline-emacs-theme))
#+END_SRC

** [[https://github.com/bbatsov/super-save][super-save]]

#+BEGIN_QUOTE
super-save auto-saves your buffers, when certain events happen - e.g.
you switch between buffers, an Emacs frame loses focus, etc. You can
think of it as both something that augments and replaces the standard
=auto-save-mode=.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package super-save
  :ensure t
  :diminish super-save-mode
  :config (super-save-mode +1))
#+END_SRC

** [[https://github.com/ternjs/tern][tern]]

#+BEGIN_SRC emacs-lisp
(use-package tern
  :ensure t
  :commands tern-mode
  :load-path "/home/nelson/src/github/elisp/tern/emacs"
  :diminish tern-mode
  :init (add-hook 'js2-mode-hook 'tern-mode))

(use-package company-tern
  :ensure t
  :init (add-to-list 'company-backends 'company-tern))
#+END_SRC

** [[https://melpa.org/#/transpose-frame][transpose-frame]]

Allows for transposing window arrangements.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package transpose-frame
  :ensure t
  :bind ("S-M-t" . transpose-frame))
#+END_SRC

** [[http://melpa.org/#/undo-tree][undo-tree]]

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :commands global-undo-tree-mode)
#+END_SRC

** [[https://github.com/mrkkrp/vimish-fold][vimish-fold]]

#+BEGIN_SRC emacs-lisp :tangle no
(use-package vimish-fold
  :ensure t
  :config (vimish-fold-global-mode 1)
  )
#+END_SRC

** [[https://github.com/joodland/bm][visible-bookmarks]]

Provides visible, buffer local, bookmarks and the ability to jump
forward and backward to the next bookmark.

#+BEGIN_SRC emacs-lisp
(use-package bm
  :ensure t
  :bind ("C-<f4>" . bm-toggle)
        ("A-<f4>" . bm-next)
        ("S-<f4>" . bm-previous))
#+END_SRC

** [[https://github.com/benma/visual-regexp.el][visual-regexp]]

visual-regexp for Emacs is like replace-regexp, but with live visual
feedback directly in the buffer.

visual-regexp-steroids is an extension to visual-regexp which enables
the use of modern regexp engines (no more escaped group parentheses,
and other goodies!).

#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :ensure t
  :init
  (use-package visual-regexp-steroids :ensure t)
  :bind (("C-c r" . vr/replace)
         ("C-c q" . vr/query-replace)
         ("C-c m" . vr/mc-mark) ; Need multiple cursors
         ("C-M-r" . vr/isearch-backward)
         ("C-M-s" . vr/isearch-forward)))

(defun nl/query-replace-regexp-history-clear ()
    "Using visual-regexp functions and query-replace-regexp in
the same session fails if there are invalid history characters in
the history (visual-regexp uses PCRE regexes). This function
clears the history."
  (interactive)
  (setq query-replace-defaults nil)
  (setq query-replace-history nil))
#+END_SRC

** [[https://github.com/capitaomorte/yasnippet][yasnippet]]

It takes a few seconds to load and I don't need them immediately when
Emacs starts up, so we can defer loading yasnippet until there's some
idle time.

Large collection of snippets: [[https://github.com/AndreaCrotti/yasnippet-snippets][Andrea Crotti's collection]].

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :diminish yas-minor-mode
  :init
  (yas-global-mode 1)
  :config
    (add-to-list 'yas-snippet-dirs (locate-user-emacs-file "snippets")))
#+END_SRC

** [[https://github.com/cmpitg/wand][wand]]

#+BEGIN_QUOTE
Wand is an extension that allows users to select a piece of text and perform actions based on predefined patterns.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package wand
  :ensure t
  :bind (("<C-return>" . wand:execute))
  :config
  (wand:add-rule-by-pattern :match "\\$ "
                            :capture :after
                            :action popup-shell-command)
  (wand:add-rule-by-pattern :match "https?://"
                            :capture :whole
                            :action browse-url))
#+END_SRC

** [[https://github.com/fxbois/web-mode][web-mode]]

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (setq web-mode-markup-indent-offset 2
        web-mode-css-indent-offset 2
        web-mode-code-indent-offset 2
        web-mode-enable-auto-closing t
        web-mode-enable-auto-quoting t
        web-mode-ac-sources-alist
        '(("css" . (ac-source-css-property))
          ("html" . (ac-source-words-in-buffer ac-source-abbrev))))

  (defun my-web-mode-hook ()
    "Hooks for Web mode."
    (setq web-mode-markup-indent-offset 2))
  (add-hook 'web-mode-hook  'my-web-mode-hook))
#+END_SRC

** [[https://github.com/purcell/whole-line-or-region][whole-line-or-region]]

#+BEGIN_SRC emacs-lisp
(use-package whole-line-or-region
  :ensure t
  :diminish whole-line-or-region-mode
  :config (whole-line-or-region-mode t))
#+END_SRC

** [[https://github.com/yoshiki/yaml-mode][yaml-mode]]

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode)))
#+END_SRC

** [[https://github.com/jinzhu/zeal-at-point][zeal-at-point]]

Search the word at point with Zeal

Zeal is a simple offline API documentation browser inspired by Dash
(OS X app), available for Linux and Windows.

#+BEGIN_SRC emacs-lisp
(use-package zeal-at-point
  :ensure t
  ;;:diminish
  :commands zeal-at-point)
#+END_SRC

** [[https://github.com/thierryvolpiatto/zop-to-char][zop-to-char]]

#+BEGIN_SRC emacs-lisp
(use-package zop-to-char
  :ensure t
  :bind ("M-z" . zop-up-to-char)
  :init
  (progn
    (setq zop-to-char-kill-keys '(?\C-k))
    (setq zop-to-char-quit-at-point-keys '(?\r))))
#+END_SRC
* Computer-specific settings

Load some computer-specific settings, such as the name and and email address. The way the settings
are loaded is based off of [[https://github.com/magnars/.emacs.d][Magnar Sveen's]] config.

#+BEGIN_SRC emacs-lisp
(defvar nl/user-settings-dir nil
  "The directory with user-specific Emacs settings for this
  user.")

;; Settings for currently logged in user
(require 's)
(setq nl/user-settings-dir
      (concat user-emacs-directory
              "users/"
              (s-trim (shell-command-to-string "hostname -s"))))
(add-to-list 'load-path nl/user-settings-dir)

;; Load settings specific for the current user
(when (file-exists-p nl/user-settings-dir)
  (mapc 'load (directory-files nl/user-settings-dir nil "^[^#].*el$")))
#+END_SRC

* Languages

** Identation config

Use spaces instead of ~\t~ character.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

A way to set up indentation for all programming modes. Taken from
[[http://blog.binchen.org/posts/easy-indentation-setup-in-emacs-for-web-development.html][here]].

#+BEGIN_SRC emacs-lisp
(defun nl/setup-indent (n)
  ;; java/c/c++
  (setq c-basic-offset n)
  ;; web development
  (setq coffee-tab-width n) ; coffeescript
  (setq javascript-indent-level n) ; javascript-mode
  (setq js-indent-level n) ; js-mode
  (setq js2-basic-offset n) ; js2-mode, in latest js2-mode, it's alias of js-indent-level
  (setq web-mode-markup-indent-offset n) ; web-mode, html tag in html file
  (setq web-mode-css-indent-offset n) ; web-mode, css in html file
  (setq web-mode-code-indent-offset n) ; web-mode, js code in html file
  (setq css-indent-offset n) ; css-mode
  )
#+END_SRC

** Programming mode hook.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'subword-mode)
(add-hook 'prog-mode-hook 'flyspell-prog-mode)

(defun my-common-prog-mode-settings ()
  "Enables settings common between programming language modes."
  (nl/setup-indent 3) ; indent 2 spaces width
  ;;
  ;; Set tab and CR/LF keys to call their corresponding more-general
  ;; functions.  This needs to be here to override the settings of some modes
  ;; (e.g. c++-mode changes the tab key to do a re-indent).
  ;;
  (local-set-key "\t" 'tab-to-tab-stop)
  (local-set-key "\n" 'newline-and-indent)
  (local-set-key "\r" 'newline-and-indent)
  ;;
  ;; Set paragraph/comment auto-formatting to wrap at column 100.
  ;;
  (set-fill-column 100)
  ;;
  ;; Set the comment column to zero so that lisp comment lines will act like
  ;; C++ comments (i.e. line up with the code), and not automatically indent
  ;; to column 50.
  ;;
  (setq comment-column 0)
  (push '(">=" . ?≥) prettify-symbols-alist)
  (push '("<=" . ?≤) prettify-symbols-alist)
  (push '("->" . ?→) prettify-symbols-alist)
  )

(setq makefile-mode-hook 'my-common-prog-mode-settings)
(setq sh-mode-hook       'my-common-prog-mode-settings)
#+END_SRC

** C / C++

#+BEGIN_SRC emacs-lisp
(defconst nelson-c-style
  '((c-tab-always-indent . t)
    (c-set-style "K&R")
    (c-offsets-alist . ((statement-block-intro . +)
                        (substatement-open     . 0)
                        (label                 . 0)
                        (case-label            . +)
                        (statement-cont        . +)
                        (innamespace           . 0))))
  "Nelson programming style.")

;; Customizations for all of c-mode, c++-mode, and objc-mode
(defun my-c-mode-common-hook ()
  ;; add my personal style and set it for the current buffer
  (c-add-style "NELSON-c-mode" nelson-c-style t)
  ;; offset customizations not in nelson-c-style
  (c-set-offset 'member-init-intro '++)
  ;; other customizations
  ;(c-toggle-auto-state 1) ;; Turn on auto newline
  (my-common-prog-mode-settings)
  ; makes the underscore part of a word in C and C++ modes
  (modify-syntax-entry ?_ "w" c++-mode-syntax-table)
  (modify-syntax-entry ?_ "w" c-mode-syntax-table)
  (lambda ()
    (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
      (ggtags-mode 1)))
  )

(add-hook 'c-mode-common-hook 'my-c-mode-common-hook)
(add-hook 'c-mode-common-hook 'my-c-mode-common-hook)
#+END_SRC

** Emacs lisp

#+BEGIN_SRC emacs-lisp
(setq emacs-lisp-mode-hook 'my-common-prog-mode-settings)
#+END_SRC

** Java

#+BEGIN_SRC emacs-lisp
(defun my-java-mode-hook ()
  (setq indent-tabs-mode nil
        zeal-at-point-docset "java"))

(add-hook 'java-mode-hook (lambda() (eclim-mode t)))
(add-hook 'java-mode-hook 'my-java-mode-hook)
(add-hook 'java-mode-hook 'semantic-mode)
#+END_SRC

*** =emacs-eclim=

Utillity function to restart the Eclim server.

#+BEGIN_SRC emacs-lisp
(defun nl/restart-eclim (workspace-dir)
  "Restarts the eclim server.  If it is currently active, the server is stopped first."
  (interactive (list (read-directory-name "Workspace directory: "
                                          eclimd-default-workspace nil t)))
  (if (get-buffer "*eclimd*") (stop-eclimd))
  (start-eclimd workspace-dir)
  (switch-to-buffer "*eclimd*"))
#+END_SRC

A gradle function to generate Javadoc for the project.

#+BEGIN_SRC emacs-lisp
(defun nl/gradle-javadoc ()
  "Uses gradle to build the Javadoc for the project."
  (interactive)
  (let* ((current-directory default-directory))
    (setq default-directory (locate-dominating-file default-directory "build.gradle"))
    (compile "gradle -q --console=plain javadoc")
    (setq default-directory current-directory)))
#+END_SRC

** JavaScript

#+BEGIN_SRC emacs-lisp
(setq javascript-common-imenu-regex-list
      '(("Controller" "[. \t]controller([ \t]*['\"]\\([^'\"]+\\)" 1)
        ("Controller" "[. \t]controllerAs:[ \t]*['\"]\\([^'\"]+\\)" 1)
        ("Filter" "[. \t]filter([ \t]*['\"]\\([^'\"]+\\)" 1)
        ("State" "[. \t]state[(:][ \t]*['\"]\\([^'\"]+\\)" 1)
        ("Factory" "[. \t]factory([ \t]*['\"]\\([^'\"]+\\)" 1)
        ("Service" "[. \t]service([ \t]*['\"]\\([^'\"]+\\)" 1)
        ("Module" "[. \t]module( *['\"]\\([a-zA-Z0-9_.]+\\)['\"], *\\[" 1)
        ("ngRoute" "[. \t]when(\\(['\"][a-zA-Z0-9_\/]+['\"]\\)" 1)
        ("Directive" "[. \t]directive([ \t]*['\"]\\([^'\"]+\\)" 1)
        ("Event" "[. \t]\$on([ \t]*['\"]\\([^'\"]+\\)" 1)
        ("Config" "[. \t]config([ \t]*function *( *\\([^\)]+\\)" 1)
        ("Config" "[. \t]config([ \t]*\\[ *['\"]\\([^'\"]+\\)" 1)
        ("OnChange" "[ \t]*\$(['\"]\\([^'\"]*\\)['\"]).*\.change *( *function" 1)
        ("OnClick" "[ \t]*\$([ \t]*['\"]\\([^'\"]*\\)['\"]).*\.click *( *function" 1)
        ("Watch" "[. \t]\$watch( *['\"]\\([^'\"]+\\)" 1)
        ("Function" "function[ \t]+\\([a-zA-Z0-9_$.]+\\)[ \t]*(" 1)
        ("Function" "^[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*=[ \t]*function[ \t]*(" 1)
        ("Task" "[. \t]task([ \t]*['\"]\\([^'\"]+\\)" 1)
        ))

;; js-mode imenu enhancement
;; @see http://stackoverflow.com/questions/20863386/idomenu-not-working-in-javascript-mode
(defun nl-js-imenu-make-index ()
  (save-excursion
    (imenu--generic-function javascript-common-imenu-regex-list)))

(defun nl/javascript-mode-hook ()
  (nl/setup-indent 2) ; indent 2 spaces width
  (setq comment-multi-line t)
  (define-key js-mode-map [remap indent-new-comment-line]
    'c-indent-new-comment-line)
  (setq indent-tabs-mode nil)
  (setq imenu-create-index-function 'nl-js-imenu-make-index)
  (flycheck-mode t))

;;(add-hook 'js-mode-hook 'js2-minor-mode)
(add-hook 'js2-mode-hook 'fic-mode)
(add-hook 'js2-mode-hook 'nl/javascript-mode-hook)
(add-hook 'js2-mode-hook 'my-common-prog-mode-settings)
;;(add-hook 'js2-mode-hook 'js2-imenu-extras-mode)
#+END_SRC

Key bindings to allow us to use ~counsel-ag~ to seach scala code.

#+BEGIN_SRC emacs-lisp
(defun nl/counsel-ag-js ()
  "Perform counsel-ag on the project's JavaScript files."
  (interactive)
  (counsel-ag "" (projectile-project-root) "--js"))

(global-set-key (kbd "C-c s j") 'nl/counsel-ag-js)
#+END_SRC

** Html

#+BEGIN_SRC emacs-lisp
(defun nl/counsel-ag-html ()
  "Perform counsel-ag on the project's HTML files."
  (interactive)
  (counsel-ag "" (projectile-project-root) "--html"))

(global-set-key (kbd "C-c s h") 'nl/counsel-ag-html)
#+END_SRC

** Perl

#+BEGIN_SRC emacs-lisp
(defun my-cperl-setup ()
  (cperl-set-style "C++")
  (my-common-prog-mode-settings))

(add-hook 'cperl-mode-hook 'my-cperl-setup)
#+END_SRC

** PHP

#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :ensure t
  :mode "\\.php[345]?\\'")
#+END_SRC

** Scala

I use these within a hydra to make testing scala code easier.

#+BEGIN_SRC emacs-lisp
;; created after reading this article:
;;
;; http://kitchingroup.cheme.cmu.edu/blog/2015/01/24/Anatomy-of-a-helm-source/
(setq nl/helm-scala-project-test-spec
      '((name . "Select a ScalaTest specification to run:")
        (candidates
         . (lambda ()
             (remove-if-not (lambda (filename)
                              (string-match "Spec.scala$" filename))
                            (projectile-current-project-files))
             ))
        (nomark . t)
        (action
         . (lambda (candidate)
             ;;(message "file name is: %s" candidate)
             ;;(message "test name is: %s" (file-name-nondirectory candidate))
             (sbt-command (message "test-only *%s"
                                   (file-name-sans-extension (file-name-nondirectory candidate))))
             ))))

(defun nl/scalatest-test-only ()
  (interactive)
  (helm :sources '(nl/helm-scala-project-test-spec)))

(defun nl/scalatest-test-only-this-buffer ()
  "For the class in the current buffer, run the scalatest test suite.
The class name must have the postfix 'Spec' for this function to work."
  (interactive)
  (save-excursion
    (let (p1 p2 line spec-name)
    (goto-char (point-min))
    (re-search-forward "class.*Spec")
    (setq p1 (line-beginning-position) )
    (setq p2 (line-end-position) )
    (setq line (buffer-substring-no-properties p1 p2))
    (save-match-data ; is usually a good idea
      (and (string-match "class \\(\\w+\\).*Spec" line)
           (setq spec-name (concat (match-string 1 line) "Spec"))))
    ;;(message "%s" spec-name)
    (sbt-command (message "testOnly *%s" spec-name)))))

(defun nl/scalatest-find-file ()
  "From an scalatest failure backtrace, opens the file under the cursor at the line specified."
  (interactive)
  (let (p1 p2 err-line filename line-num file-with-proj-path)
    (save-some-buffers t)
    (setq p1 (line-beginning-position) )
    (setq p2 (line-end-position) )
    (setq err-line (buffer-substring-no-properties p1 p2))
    (save-match-data ; is usually a good idea
      (and (string-match "\\[info\\]\\s-+at\\s-+org.biobank[^(]+(\\([^:]+\\):\\([0-9]+\\))" err-line)
           (setq filename (concat "/" (match-string 1 err-line)) ; add leading slash as a delimiter
                 line-num (string-to-number (match-string 2 err-line))
                 )))
    (setq file-with-proj-path
          (car (remove-if-not
                (lambda (projfile)
                  (string-match filename projfile))
                (projectile-current-project-files))))
    (message "%s %s" file-with-proj-path line-num)
    (find-file-other-window (expand-file-name file-with-proj-path (projectile-project-root)))
    (goto-char (point-min))
    (forward-line (- line-num 1))))

(defun nl/scalatest-remove-tag ()
  "Removes a ScalaTest tag searching forward in the buffer"
  (interactive)
  (search-forward "taggedAs")
  (skip-chars-backward "A-Za-z0-9")
  (setq head-point (point))
  (skip-chars-forward "A-Za-z0-9(\")")
  (forward-char)
  (setq tail-point (point))
  (kill-region head-point tail-point))

(defhydra hydra-nl-scalatest (:hint nil)
  "Testing scala code with scalatest"
  ("t" nl/scalatest-test-only-this-buffer "this file" :color blue)
  ("s" nl/scalatest-test-only "select suite to run" :color blue)
  ("f" nl/scalatest-find-file "find file from traceback" :color blue)
  ("r" nl/scalatest-remove-tag "remove test tag" :color blue))
#+END_SRC

More functions that are used in scala-mode.

#+BEGIN_SRC emacs-lisp
(defun scala-mode-newline-comments ()
  "Custom newline appropriate for `scala-mode'."
  ;; shouldn't this be in a post-insert hook?
  (interactive)
  (newline-and-indent)
  (scala-indent:insert-asterisk-on-multiline-comment))

(defun nl/scala-mode-keys ()
  "My extra key definitions for 'scala-mode'."
  (interactive)
  ;; use sbt-run-previous-command to re-compile your code after changes
  (local-set-key (kbd "C-x '") 'sbt-run-previous-command)
  (local-set-key (kbd "RET") 'newline-and-indent)
  ;; Bind the backtab (shift tab) to
  ;; 'scala-indent:indent-with-reluctant-strategy command. This is usefull
  ;; when using the 'eager' mode by default and you want to "outdent" a
  ;; code line as a new statement.
  (local-set-key (kbd "<backtab>") 'scala-indent:indent-with-reluctant-strategy)
  (bind-key "M-j" 'scala-mode-newline-comments scala-mode-map))

  (defun nl-scala-mode-hook ()
    (yas-minor-mode)
    ;; sbt-find-definitions is a command that tries to find (with grep)
    ;; the definition of the thing at point.
    ;;(local-set-key (kbd "M-.") 'sbt-find-definitions)

    (setq-default indent-tabs-mode nil)
    (setq compilation-ask-about-save nil)
    (nl/scala-mode-keys))

(key-chord-define-global "jt" 'hydra-nl-scalatest/body)
#+END_SRC

Key bindings to allow us to use ~counsel-ag~ to seach scala code.

#+BEGIN_SRC emacs-lisp
(defun nl/counsel-ag-scala ()
  "Perform counsel-ag on the project's Scala files."
  (interactive)
  (counsel-ag "" (projectile-project-root) "--scala"))
(global-set-key (kbd "C-c s s") 'nl/counsel-ag-scala)
#+END_SRC

Use the package.

#+BEGIN_SRC emacs-lisp
(use-package scala-mode
  :ensure t
  ;;:load-path "/home/nelson/src/github/elisp/emacs-scala-mode"
  :interpreter
  ("scala" . scala-mode)
  :config
  (setq scala-indent:indent-value-expression t
        scala-indent:align-parameters t
        scala-indent:align-forms t
        scala-indent:default-run-on-strategy '2 ;; scala-indent:reluctant-strategy
        scala-indent:use-javadoc-style t)
  (add-hook 'scala-mode-hook 'nl-scala-mode-hook)
  (add-hook 'scala-mode-hook 'fic-mode))
#+END_SRC

Also use the ~sbt-mode~ package.

#+BEGIN_SRC emacs-lisp
(defun nl-sbt-mode-hook ()
  ;; compilation-skip-threshold tells the compilation minor-mode which type of compiler output can
  ;; be skipped. 1 = skip info 2 = skip info and warnings.
  (setq compilation-skip-threshold 1)

  ;; Bind C-a to 'comint-bol when in sbt-mode. This will move the cursor to just after prompt.
  (local-set-key (kbd "C-a") 'comint-bol)

  ;; Bind M-RET to 'comint-accumulate. This will allows one to add more than one line to the scala
  ;; console prompt before sending it for interpretation. It keeps the command history cleaner.
  (local-set-key (kbd "M-RET") 'comint-accumulate))

(use-package sbt-mode
  :ensure t
  ;;:load-path "/home/nelson/src/github/elisp/emacs-sbt-mode"
  :commands (sbt-start sbt-command)
  :config
  (add-hook 'sbt-mode-hook 'ansi-color-for-comint-mode-on)
  (add-hook 'sbt-mode-hook 'nl-sbt-mode-hook)
  ;; set this regex so that it knows about Play Framework SBT prompt
  (setq sbt:sbt-prompt-regexp "^\\[[^]]+\\]\\s-*\\$\\s-*"
        sbt:scroll-to-bottom-on-output nil))
#+END_SRC

Ivy and =sbt-command= do not behave well together right now, define
our own wrapper function.

#+BEGIN_SRC emacs-lisp
(defun nl-sbt-command ()
  (interactive)
  (setq completing-read-function 'completing-read-default)
  (call-interactively 'sbt-command)
  (setq completing-read-function 'ivy-completing-read))

;;;; testing
(defun sbt-command-ivy ()
  "Send a command to the sbt process of the current buffer's sbt project.
Prompts for the command to send when in interactive mode. You can
use tab completion.

This command does the following:
  - displays the buffer moving focus to it if focus is t
  - erases the buffer
  - forgets about compilation errors

The command is most usefull for running a compilation command
that outputs errors."
  (interactive)
  (setq sbt:command-history-temp
        (ignore-errors (with-current-buffer (sbt:buffer-name) (ring-elements comint-input-ring))))
  (ivy-read (format "Command to run (default %s): " (sbt:get-previous-command))
            #'sbt:get-sbt-completions-for-command
            :action #'sbt:command
            :history 'sbt:command-history-temp
            :preselect (sbt:get-previous-command)
            :dynamic-collection t))
#+END_SRC

** SQL

This configuration allows me to connect to predefined MySQL servers.

Taken from:
- http://truongtx.me/2014/08/23/setup-emacs-as-an-sql-database-client/

#+BEGIN_SRC emacs-lisp
(require 'epa-file)
(epa-file-enable)

(setq sql-connection-alist
      '((localhost.dev (sql-product 'mysql)
                 (sql-port 3306)
                 (sql-server "localhost")
                 (sql-user "root")
                 (sql-database "mysql"))
        (obelix.dev (sql-product 'mysql)
                    (sql-port 3306)
                    (sql-server "localhost")
                    (sql-user "root")
                    (sql-database "mysql"))))

(defun nl/sql-connect (product connection)
  "Connects to a database server of type PRODUCT using the CONNECTION type."
  (require 'nl-passwords (concat user-emacs-directory "my-password.el.gpg"))

  ;; update the password to the sql-connection-alist
  (let ((connection-info (assoc connection sql-connection-alist))
        (sql-password (car (last (assoc connection nl-sql-passwords)))))
    (delete sql-password connection-info)
    (nconc connection-info `((sql-password ,sql-password)))
    (setq sql-connection-alist (assq-delete-all connection sql-connection-alist))
    (add-to-list 'sql-connection-alist connection-info))

  ;; connect to database
  (setq sql-product product)
  (if current-prefix-arg
      (sql-connect connection connection)
    (sql-connect connection)))

(defun nl/sql-localhost-dev ()
  "Connects to the MySQL server running on machine 'localhost'."
  (nl/sql-connect 'mysql 'localhost.dev))

(defun nl/sql-obelix-dev ()
  "Connects to the MySQL server running on machine 'obelix'."
  (nl/sql-connect 'mysql 'obelix.dev))

(defvar nl/sql-servers-list
  '(("localhost dev" nl/sql-localhost-dev)
    ("Obelix Dev" nl/sql-obelix-dev))
  "A list of server name and the function to connect.")

(defun nl/sql-connect-server (func)
  "Connect to the input server using nl/sql-servers-list and FUNC."
  (interactive
   (helm-comp-read "Select server: " nl/sql-servers-list))
  (funcall func))
#+END_SRC
* Misc
** Constants

Is some cases we need to know what type of OS Emacs is running under.

#+BEGIN_SRC emacs-lisp :tangle no
(defconst ostype-linux
  (if (integer-or-marker-p
       (string-match "linux" system-configuration)) t nil))

(defconst ostype-windows
  (if (integer-or-marker-p
       (string-match "pc-mingw32" system-configuration)) t nil))
#+END_SRC

** Aligning things

Align by colons (handy for JavaScript), align by commas, and align by
equal signs.

Borrowed from:

http://danconnor.com/post/5028ac91e8891a000000111f/align_and_columnize_key_value_data_in_emacs

#+BEGIN_SRC emacs-lisp
(defun align-colons (beg end)
  (interactive "r")
  (align-regexp beg end ":\\(\\s-*\\)" 1 1 t))

(defun align-commas (beg end)
  (interactive "r")
  (align-regexp beg end ",\\(\\s-*\\)" 1 1 t))

(defun align-equals (beg end)
  (interactive "r")
  (align-regexp beg end "\\(\\s-*\\)=" 1 1 t))

(defun align-parameters (beg end)
  (interactive "r")
  (align-regexp beg end "\\w+\\(\\s-*\\)\\w+,?" 1 1 t))

(defhydra hydra-nl-align (:hint nil)
  "Align things"
  (":" align-colons "colons" :color blue)
  ("," align-commas "commas" :color blue)
  ("=" align-equals "equals" :color blue)
  ("p" align-parameters "parameters" :color blue))

(key-chord-define-global "aa" 'hydra-nl-align/body)
#+END_SRC

** Font size

Using this hydra instead of method below, which is tangled out.

#+BEGIN_SRC emacs-lisp
;;
;; Taken from http://doc.rix.si/org/fsem.html
;;
(defhydra hydra-zoom (global-map "C-c z")
  "zoom"
  ("g" text-scale-increase "in")
  ("l" text-scale-decrease "out"))
#+END_SRC

=C-c C-+= and =C-c C--= are pretty useful, but only resize the current
buffer.  Here's a hack using ~set-frame-font~ and altering the font
size only:

#+BEGIN_SRC emacs-lisp :tangle no
(defun my-alter-frame-font-size (fn)
  (let* ((current-font-name (frame-parameter nil 'font))
         (decomposed-font-name (x-decompose-font-name current-font-name))
         (font-size (string-to-int (aref decomposed-font-name 5))))
    (aset decomposed-font-name 5 (int-to-string (funcall fn font-size)))
    (set-frame-font (x-compose-font-name decomposed-font-name))))

(defun my-inc-frame-font-size ()
  (interactive)
  (my-alter-frame-font-size '1+))

(defun my-dec-frame-font-size ()
  (interactive)
  (my-alter-frame-font-size '1-))

(global-set-key (kbd "C-+") 'my-inc-frame-font-size)
(global-set-key (kbd "C--") 'my-dec-frame-font-size)
#+END_SRC

** Date and time stamps

Used for inserting date and time stamps, or date stamps into the
current buffer at the current location. I define my own format for
these.

#+BEGIN_SRC emacs-lisp
(defconst nl/dts-format-string "%Y-%m-%d %H:%M:%S"
  "A string specifying the format of the date-time stamp.
Refer to the documentation for 'format-time-string' for an explanation of the
meta characters available for use in this string.  Non-meta characters will
be inserted into the buffer without interpretation.")

(defvar nl/ds-format-string "%Y-%m-%d"
  "A string specifying the format of the date stamp.
Refer to the documentation for 'format-time-string' for an explanation of the
meta characters available for use in this string.  Non-meta characters will
be inserted into the buffer without interpretation.")

(defun nl/insert-dts ()
  "Insert the date and time into the current buffer at the current location.
See the documentation for nl/dts-format-string to change the format of the
date-time stamp."
  (interactive)
  (insert (format-time-string nl/dts-format-string (current-time))))

(defun nl/insert-ds ()
  "Insert the date into the current buffer at the current location.
See the documentation for nl/dts-format-string to change the format of the
date-time stamp."
  (interactive)
  (insert (format-time-string nl/ds-format-string (current-time))))

#+END_SRC

** Journal

I keep notes in an org-mode file in my Dropbox folder. When I add
something to it in automatially inserts a time stamp.

#+BEGIN_SRC emacs-lisp
(defun nl/journal ()
  "Add an entry in the journal file."
  (interactive)
  (find-file "~/Dropbox/journal.org")
  (end-of-buffer)
  (insert "\n\n")
  (insert "* ")
  (nl/insert-dts)
  (insert "\n")
  )
#+END_SRC

** Occur

The following function for ~occur-dwim~ is taken from [[https://github.com/abo-abo][Oleh Krehel]] from
[[http://oremacs.com/2015/01/26/occur-dwim/][his blog post at (or emacs]]. It takes the current region or the symbol
at point as the default value for occur.

#+BEGIN_SRC emacs-lisp
(defun occur-dwim ()
  "Call `occur' with a sane default."
  (interactive)
  (push (if (region-active-p)
            (buffer-substring-no-properties
             (region-beginning)
             (region-end))
          (thing-at-point 'symbol))
        regexp-history)
  (call-interactively 'occur))
#+END_SRC

** Camelcase to upper

Coverts camel case words to uppercase with underscore as delimiters.

#+BEGIN_SRC emacs-lisp
(defun nl/camelcase-to-upper ()
  (interactive)
  (replace-regexp "\\([A-Z]\\)" "_\\1" nil (region-beginning)(region-end))
  (upcase-region (region-beginning)(region-end)))
#+END_SRC

** Windows

*** Functions

Views the same file side by side:

#+BEGIN_SRC emacs-lisp
(defun nl/frame-grow-horizontally ()
  "Set the size and position of the Emacs window."
  (interactive)
  (let ((frame (selected-frame)))
    (set-frame-size frame (* 2 (frame-width)) (frame-height))
    ))

(defun nl/frame-shrink-horizontally ()
  "Set the size and position of the Emacs window."
  (interactive)
  (let ((frame (selected-frame)))
    (set-frame-size frame (/ (frame-width) 2) (frame-height))
    ))

(defhydra hydra-nl-frame-resize (:hint nil)
  "Frame resize"
  ("g" nl/frame-grow-horizontally "grow" :color blue)
  ("s" nl/frame-shrink-horizontally "shrink" :color blue))

(global-set-key [f9] 'hydra-nl-frame-resize/body)

(defun nl/split-view-same-file ()
  (interactive)
  (windmove-right)
  (delete-window)
  (split-window-right)
  (windmove-right))

(global-set-key [S-f9] 'nl/split-view-same-file)
#+END_SRC

*** Font

#+BEGIN_SRC emacs-lisp :tangle no
(when ostype-windows
    (set-face-attribute 'default nil :font "InputMonoCondensed Medium-9"))
#+END_SRC

** Narrow or widen

From [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Artur Malabarba]]'s blog:

#+BEGIN_SRC emacs-lisp
(defun narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or defun,
whichever applies first. Narrowing to org-src-block actually
calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer is
already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning) (region-end)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing
         ;; command. Remove this first conditional if you
         ;; don't want it.
         (cond ((ignore-errors (org-edit-src-code))
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        ((derived-mode-p 'latex-mode)
         (LaTeX-narrow-to-environment))
        (t (narrow-to-defun))))

;;(define-key endless/toggle-map "n" #'narrow-or-widen-dwim)
;; This line actually replaces Emacs' entire narrowing
;; keymap, that's how much I like this command. Only copy it
;; if that's what you want.
(define-key ctl-x-map "n" #'narrow-or-widen-dwim)
(add-hook 'LaTeX-mode-hook
          (lambda () (define-key LaTeX-mode-map "\C-xn" nil)))
(eval-after-load 'org-src
  '(define-key org-src-mode-map
     "\C-x\C-s" #'org-edit-src-exit))

(defun modi/multi-pop-to-mark (orig-fun &rest args)
  "Call ORIG-FUN until the cursor moves.
Try the repeated popping up to 10 times."
  (let ((p (point)))
    (dotimes (i 10)
      (when (= p (point))
        (apply orig-fun args)))))
(advice-add 'pop-to-mark-command :around
            #'modi/multi-pop-to-mark)
#+END_SRC

** Search symbol

From [[http://endlessparentheses.com/quickly-search-for-occurrences-of-the-symbol-at-point.html?source%3Drss][Endless Parentheses blog]].

#+BEGIN_SRC emacs-lisp
(defun endless/isearch-symbol-with-prefix (p)
  "Like isearch, unless prefix argument is provided.
With a prefix argument P, isearch for the symbol at point."
  (interactive "P")
  (let ((current-prefix-arg nil))
   (call-interactively
     (if p #'isearch-forward-symbol-at-point
       #'isearch-forward))))

(global-set-key [remap isearch-forward]
                #'endless/isearch-symbol-with-prefix)
#+END_SRC

# Local Variables:
# org-src-preserve-indentation: nil
# org-edit-src-content-indentation: 0
# End:
